/**
 * Author: thecodekaiser
 * Note  : The following code is an attempt to write the famous Algorithm X (that solves)
 * 	   exact-cover problem using the Dancing-Links Algorithm.I studied it from various
 * 	   sources and but I would like to credit: Andy Giese, whose blog helped me in the implementation
 *         This is the link: https://gieseanw.wordpress.com/2011/06/16/solving-sudoku-revisited/
 * 
 * 	   Following algo can be implemented for all sizes, you just need to change the constants defined
 * 	   in the beginning. It uses the S-heuristic in selecting a constraint (selects that column that has
 *	   the min no of 1s in it) to reduce the branching factor.
 */
#include <bits/stdc++.h>
using namespace std;

// Defining the dimensions of the matrix
#define MATRIX_SIZE 9		// No of digits we are using currently
#define MAX_COLS    324		// Actually Columns represent constraints.. No of constraints = 4 * (MATRIX_SIZE)^2
#define MAX_ROWS    729	 	// Actually Rows    represent possibility.. No of possibility = (MATRIX_SIZE) ^ 3

#define ROW_OFFSET   0		// This is is how I am going to divide the matrix.. 
#define COL_OFFSET   81		// Row Constraints -> Col Constraints -> Cell Constraints -> Box Constraints
#define CELL_OFFSET  162
#define BOX_OFFSET   243

#define COL_BOX_DIVISOR 3	// No of columns in a box
#define ROW_BOX_DIVISOR 3	// No of rows in a box


// Now a word about the node of the linked list..it is a quadruply linked circular list node 
// that has connections in all four directions.
struct Node
{
	Node * left, * right, * up, * down;	// Usual connections
	Node * colHeader;			// To identify the column
	
	int row, col, value, size;	
	bool header;				// To identify if it is a column header node

	// Constructor
	Node()	{ left = right = up = down = colHeader = NULL; row = col = value = -1; size = 0; header = false; }
	
	Node(int r, int c, int v)
	{ left = right = up = down = colHeader = NULL; row = r, col = c, value = v; size = 0; header = false; }
};

// Class : Sudoku Matrix
class SudokuMatrix
{
private:
	Node * root;			// Points to the first node in the list of the column headers
	stack<Node> * workingSolution;	// The partial or full solution to current puzzle
	bool solved;			// To check if a working solution has been found

	// Function: Helps in adding a new column node to the list of already created column nodes
	bool AddColumnHelp(Node * newNode, Node * r)
	{
		// Don't allow duplicate nodes..
		if	(r -> right == root and r != newNode)
		{
			// r will be the last node in the list currently
			r -> right -> left = newNode;		// r -> right is currently root
			newNode -> right   = r -> right;	
			r -> right	   = newNode;		// Now point root back to newNode
			newNode -> left    = r;

			return true;
		}
		else if	(newNode == r)
			return false;
		else
			return AddColumnHelp(newNode, r -> left);	// We are assuming that r will always be root when 
									// it is passed to the function
	}

	// Function: Helper function in the destructor
	void deleteMatrix()
	{
		Node * nextCol = root -> right; 	// First column to be deleted
		Node * nextRow, * temp;

		// While you don't reach the root again
		while(nextCol != root)
		{
			nextRow = nextCol -> down;
			// While it's not a special column header node
			while(! nextRow -> header)	
			{
				temp = nextRow -> down;
				delete nextRow;
				nextRow = temp;		// Move down one step
			}

			temp = nextCol -> right;
			delete nextCol;
			nextCol = temp;
		}		
	}

	// Function: To insert a new column in the list of already present column headers
	bool AddColumn(Node * newNode)
	{
		if(! newNode -> header)
			return false;	// If it is not a column header node then return false
		else
			return AddColumnHelp(newNode, root);
	}

	// Function : To cover some column	*Very Important*
	void cover(Node * r)
	{
		Node * rowNode, * rightNode, * colNode = r -> colHeader;
		colNode -> left -> right = colNode -> right;
		colNode -> right -> left = colNode -> left;
	
		for(rowNode = colNode -> down; rowNode != colNode; rowNode = rowNode -> down)
		{
			for(rightNode = rowNode -> right; rightNode != rowNode; rightNode = rightNode -> right)
			{
				rightNode -> up -> down = rightNode -> down;
				rightNode -> down -> up = rightNode -> up;
			}
		}
	}

	// Function : To uncover a column.Now we go in the opposite direction as we went in the cover function
	void uncover(Node * r)
	{
		Node * rowNode, * leftNode, * colNode = r -> colHeader;
		
		for(rowNode = colNode -> up; rowNode != colNode; rowNode = rowNode -> up)
		{
			for(leftNode = rowNode -> left; leftNode != rowNode; leftNode = leftNode -> left)
			{
				leftNode -> up -> down = leftNode;	
				leftNode -> down -> up = leftNode;
			}
		}

		colNode -> right -> left = colNode;		// Redirected the links back to colNode
		colNode -> left -> right = colNode;
	}

public: 
	// Constructor
	SudokuMatrix()
	{
		root = new Node();
		root -> header = true;		// Yes, it's a column header

		// Root points to itself in all directions
		root -> left = root -> right = root -> up = root -> down = root; 
		workingSolution = new stack<Node>();
		solved = false;
	}

	// Destructor
	~SudokuMatrix()
	{
		deleteMatrix();
		delete root;
	}

	
	// Function : To initialize all things
	// 	      It first creates the exact cover matrix and then reads in the initial input
	// 	      From the initial input it creates the Dancing Links structure based on the initial input
	bool initialize()
	{
		Node * matrix[MAX_ROWS][MAX_COLS];
		// Initialize the matrix
		for(int i = 0; i < MAX_ROWS; i++)
		{	for(int j = 0; j < MAX_COLS; j++)	matrix[i][j] = NULL;	}

		// Set appropriate non-null values in the matrix
		int row = 0;
		for(int i = 0; i < MATRIX_SIZE; i++)		// Rows
		{
			for(int j = 0; j < MATRIX_SIZE; j++)	// Columns
			{	
				for(int k = 0; k < MATRIX_SIZE; k++)	// Values
				{
				}
			}
		}
	}

};
	

void solve()
{
	return;
}

int main()
{
	return 0;
}
